    <!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="alenstar">
		<meta name="description" content="alenstar blog">
		<meta name="generator" content="Hugo 0.36.1" />
		<title>Java 和 Kotlin 单例实现 &middot; alenstar blog</title>
		<link rel="shortcut icon" href="https://alenstar.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://alenstar.github.io/css/style.css">
		<link rel="stylesheet" href="https://alenstar.github.io/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://alenstar.github.io/css/font-awesome.min.css">
		

		
        
        
        
		
	</head>

    <body>
	<div class="body-box">
       <nav class="main-nav">
	
	
		<a href='https://alenstar.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://alenstar.github.io/post'>Archive</a>
	<a href='https://alenstar.github.io/tags'>Tags</a>
	<a href='https://alenstar.github.io/about'>About</a>

	

	
</nav>


        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>
                        Java 和 Kotlin 单例实现
                    </h1>
                    <h2 class="headline">
                    May 27, 2017 14:52
                    · 813 words
                    · 2 minutes read
                      <span class="tags">
                      
                      
                          
                              <a href="https://alenstar.github.io/tags/java">java</a>
                          
                              <a href="https://alenstar.github.io/tags/kotlin">kotlin</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<h2 id="java">Java</h2>

<p>Java中实现单例，我们可以有很多种实现方法，但是这给程序员带来了额外的负担，不仅要考虑线程安全还要考虑效率问题。</p>

<h3 id="1-懒汉实现-线程不安全">1, 懒汉实现， 线程不安全</h3>

<pre><code>public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  // 隐藏构造方法
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}  
</code></pre>

<h3 id="2-懒汉实现-线程安全">2, 懒汉实现， 线程安全</h3>

<pre><code>public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    // 使用synchronized来实现线程同步， 影响效率
    public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
} 

// 或者这样
public class Singleton {  
    private Singleton instance = null;  
    static {  
        instance = new Singleton();  
    }  
    private Singleton (){}  
    public static Singleton getInstance() {  
        return this.instance;  
    }  
}  
</code></pre>

<h3 id="3-饿汉实现">3, 饿汉实现</h3>

<pre><code>public class Singleton { 
    // class加载（ClassLoader）时实例化避免线程同步问题 
    private static Singleton instance = new Singleton(); 
    private Singleton (){}  
    public static Singleton getInstance() {  
        return instance;  
    }  
}  
</code></pre>

<h3 id="4-静态内部类">4, 静态内部类</h3>

<pre><code>public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
        // 调用getInstance时加载SingletonHolder实例化Singleton
        return SingletonHolder.INSTANCE;  
    }  
}  
</code></pre>

<h3 id="5-双重校验锁">5, 双重校验锁</h3>

<pre><code>public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  // 实例化时同步，减少同步开销
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
        return singleton;  
    }  
}
</code></pre>

<h3 id="6-枚举">6, 枚举</h3>

<p>JVM会保证enum不能被反射并且构造器方法只执行一次</p>

<pre><code>public class EnumSingleton{
    private EnumSingleton(){}
    public static EnumSingleton getInstance(){
        return Singleton.INSTANCE.getInstance();
    }
    
    private static enum Singleton{
        INSTANCE;
        
        private EnumSingleton singleton;
        //JVM会保证此方法绝对只调用一次
        private Singleton(){
            singleton = new EnumSingleton();
        }
        public EnumSingleton getInstance(){
            return singleton;
        }
    }
}
</code></pre>

<h2 id="kotlin">Kotlin</h2>

<p>Kotlin中没有 <code>静态属性</code> 和 <code>静态方法</code> ，但有关键字 <code>object</code> 和 <code>companion</code> （伴生对象 companion object）。</p>

<p><code>object</code> 修饰类的时候，该类是单例对象。</p>

<pre><code>/**
 * 使用object定义类，该类的实例即为单例，访问单例直接使用类名，
 * 不能通过构造函数进行访问，不允许有构造函数
 * Singleton.doSomething() // 访问单例对象
 */
object Singleton {
    fun doSomething() {
        println(&quot;doSomething&quot;)
    }
}


/**
 * 实例化的时候，单例是懒加载，当使用的时候才去加载；而对象表达式是在初始化的地方去加载。
 *
 * 当在类内部使用 object 关键词定义对象时，允许直接通过外部类的类名访问内部对象进
 * 而访问其相关属性和方法，相当于静态变量
 * 可以使用companion修饰单例，则访问其属性或方法时，允许省略单例名
 * SingletonClass.doSomething() // 访问内部单例对象方法
 */
class Singleton {
    companion object {
        fun doSomething() {
            println(&quot;doSomething&quot;)
        }
    }
}
</code></pre>

<p>可以看出kotlin实现单例要简单得多</p>

                </section>
            </article>
            
            
            
            

            

            

            
    
            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/alenstar">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> alenstar
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>
	</div>

	

        <script src="https://alenstar.github.io/js/jquery-2.2.4.min.js"></script>
<script src="https://alenstar.github.io/js/main.js"></script>
<script src="https://alenstar.github.io/js/highlight.min.js"></script>



<script>hljs.initHighlightingOnLoad();</script>









    </body>
</html>
